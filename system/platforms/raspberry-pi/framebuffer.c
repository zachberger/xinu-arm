//Eric Warrington//get fb//query for amt of mem//allocate, free GPU mem//execute code on GPU#include "mbox.h"#include "framebuffer.h"/* use a global variable since we have no malloc */static struct fb_info FB;/* Use some free memory in the area below the kernel/stack */#define BUFFER_ADDRESS 0x1000static void fb_error(){	//while(1)	{		printf("FB Error\n");		//led_flash_num(num, FB_ERROR_MAX_BITS);	}}void get_display_size(struct fb_info* info);void get_fb_info(struct fb_info* info);struct fb_info* fb_init(){	struct fb_info* info = &FB;	get_display_size(info);	get_fb_info(info);	return info;}void get_display_size(struct fb_info* info){	volatile u32* buf=(u32*)BUFFER_ADDRESS;	int w, h;	buf[0] = 8 * 4; /* buffer size */	buf[1] = 0; /* request/response code */	/* tag - get physical display size*/	buf[2] = 0x40003; /* tag id */	buf[3] = 8; /* value buffer size */	buf[4] = 0+0; /* request indicator + size */	buf[5] = 0; /* req: width */	buf[6] = 0; /* req: height */	buf[7] = 0; /* end tags */	mailbox_write(MAIL_CHAN_ARMTOVC_PROP, (u32)buf);	mailbox_read(MAIL_CHAN_ARMTOVC_PROP);	if(buf[1]!=MAIL_PROP_RESPONSE_OK)	{		fb_error();		return;	}	w = buf[5];	h = buf[6];	if(!w && !h)	{		w = 640;		h = 480;	}	if(!w || !h)	{		fb_error();		return;	}	info->width = w;	info->height = h;}void get_fb_info(struct fb_info* info){	volatile u32* buf=(u32*)BUFFER_ADDRESS;	u32 w = info->width;	u32 h = info->height;	u32 i = 0;	u32 buf_size = 0;	u32 fb_base;	u32 fb_size;	buf[i++] = 0; /* buffer size; compute later */	buf[i++] = 0; /* request/response code */	/* tag - set physical size */	buf[i++] = 0x48003; /* tag id */	buf[i++] = 8; /* value buffer size */	buf[i++] = 0+8; /* request indicator + size */	buf[i++] = w; /* req: width */	buf[i++] = h; /* req: height */	/* tag - set virtual size */	buf[i++] = 0x48004; /* tag id */	buf[i++] = 8; /* value buffer size */	buf[i++] = 0+8; /* request indicator + size */	buf[i++] = w; /* req: width */	buf[i++] = h; /* req: height */	/* tag - set depth */	buf[i++] = 0x48005; /* tag id */	buf[i++] = 4; /* value buffer size */	buf[i++] = 0+4; /* request indicator + size */	buf[i++] = 16; /* req: depth */	/* tag - allocate framebuffer */	buf[i++] = 0x40001; /* tag id */	buf[i++] = 8; /* value buffer size */	buf[i++] = 0+4; /* request indicator + size */	buf[i++] = 16; /* req: alignment; resp: fb base addr */	buf[i++] = 0; /* resp: fb size */	buf[i++] = 0; /* end tags */	buf_size=i;	buf[0] = buf_size * 4; /* buffer size */	mailbox_write(MAIL_CHAN_ARMTOVC_PROP, (u32)buf);	mailbox_read(MAIL_CHAN_ARMTOVC_PROP);	if(buf[1]!=MAIL_PROP_RESPONSE_OK)	{		fb_error();		return;	}	/* jump to the last tag since we're only interested in this one */	i = 2; /* first tag */	while(buf[i]!=0x40001)	{		/* skip to next tag */		i += 3 + (buf[i+1] >> 2);		if(i >= buf_size)		{			fb_error();			return;		}	}	fb_base = buf[i+3];	fb_size = buf[i+4];	if(!fb_base || !fb_size)	{		fb_error();		return;	}	info->fb_ptr=fb_base;	info->fb_size=fb_size;}u32 fb_pitch(){	volatile u32* buf=(u32*)BUFFER_ADDRESS;	int w, h;	buf[0] = 6 * 4; /* buffer size */	buf[1] = 0; /* request/response code */	/* tag - get pitch*/	buf[2] = 0x40008; /* tag id */	buf[3] = 4; /* value buffer size */	buf[4] = 0+0; /* request indicator + size */	buf[5] = 0; /* req: width */	buf[6] = 0; /* end tags */	mailbox_write(MAIL_CHAN_ARMTOVC_PROP, (u32)buf);	mailbox_read(MAIL_CHAN_ARMTOVC_PROP);	if(buf[1]!=MAIL_PROP_RESPONSE_OK)	{		fb_error();		return;	}	return buf[5];}